定义在块中的变量具有块作用域：从定义处到包含该定义的块的末尾
形式变量也具有块作用域

for、while、do while、if语句控制的代码即使没有花括号，也算是块的一部分
for(int i = 0; i<10; i++)
i的作用域仅限于for循环

函数作用域仅用于goto语句的标签

函数原型作用域用于函数原型中的形参名：原型中的形参名不必与定义中的形参名相匹配
函数原型不关心形参名，只有在变长数组中，形参名才有用

变量定义在函数外面具有文件作用域，也称全局变量

实际上头文件被包含于源文件时，一个具有文件作用域的变量的实际可见范围是整个翻译单元，每个翻译单元对应一个源文件和它所包含的头文件

文件作用域变量具有静态存储期
对于文件作用域变量，static标明的是其链接属性，而非存储期

线程存储期用于并发程序设计，从被声明到线程结束一直存在
关键字	_Thread_local

块作用域变量具有自动存储期，当进入这个块时分配内存，退出时释放内存
变长数组稍有不同，存储期是从声明处到块的末尾

对于块作用域变量，static标明的是静态存储期

自动存储：具有自动存储期，块作用域且无链接
auto是存储类别说明符，在C++中的用法不同

在循环条件中用的x是外部x，内部定义的x在每次迭代时会重新创建
循环体是循环的子块，在循环条件中定义的x，循环体中再次定义x会隐藏循环条件的x

自动变量不会初始化，可以用非常量表达式初始化自动变量

register声明寄存器变量，位于寄存器故无法获取地址
块作用域，无链接，自动存储期
但是编译器有可能忽略这个请求，此时寄存器变量就变成普通的自动变量
寄存器可能没有足够大的空间储存double类型的值

块作用域的静态变量，程序离开它们所在的函数后，这些变量不会消失
块作用域，无链接，静态存储期
静态变量只在编译时被初始化一次，如果未显式初始化，则初始化为0
逐步调试程序时，程序似乎跳过此声明，因为静态变量和外部变量在程序
载入内存时已执行完毕

不能在函数的形参中用static

外部链接的静态变量具有文件作用域，外部链接，静态存储期
称为外部存储类别，外部变量，关键字extern
将变量声明放在函数外面便创建了外部变量
如果一个源文件中使用的变量声明在另一个源文件中，必须用extern在使用此变量的文件中声明此变量
在函数外已声明外部变量，函数内部可以使用extern重复声明此变量，这是可选的，仅表示此函数要使用这个外部变量（称为引用式声明）
函数中创建同名的自动变量，自动变量会将外部变量隐藏，最好使用auto明确表达这种意图

声明在函数后面的外部变量对前面的函数不可见
外部变量的作用域从声明处到文件结尾

未显式初始化外部变量，自动初始化为0，也适用于外部定义的数组
只能用常量表达式初始化文件作用域变量，例如不能
int x2 =  2 * x;
只要不是变长数组，sizeof表达式视为常量表达式

编译器识别局部标识符的前63个字符和外部标识符的前31个字符

不要用extern创建外部定义，编译器会假设实际的定义在程序别处
只用extern来引用现有的外部定义
外部变量只能初始化一次，且必须在定义时初始化

内部链接的静态变量具有静态存储期，文件作用域，内部链接
关键字static
外部变量可用于同一程序中任意文件中的函数，内部链接的静态变量只能用于同一个文件中的函数，可以使用存储类别说明符extern重复声明任何具有文件作用域的变量，并不改变变量的链接属性

不能用多个存储类别说明符作为typedef的一部分，唯一例外是_Thread_local可以和extern或者static一起使用

auto和register只用于块作用域的变量，register保护变量的地址不被获取

具有文件作用域的变量对文件或翻译单元中位于声明后的函数可见

rand()使用内部链接的静态变量

malloc()的内存是匿名的，但返回动态分配内存块的首字节地址，返回指向void的指针。
若分配内存失败，返回空指针
malloc()的参数为字节数

变长数组只能在自动内存中创建

free()的参数是之前malloc()返回的地址

C中不一定要强制类型转换，但C++中必须使用

calloc()接受两个无符号整数作为参数，第一个是存储单元数，第二个是存储单元的大小
calloc()将块中所有位都设置为0

不能释放同一块内存两次

自动变量的内存通常作为栈来处理
动态内存通常比栈内存慢

const和volatile限定符
restrict限定符提高编译器优化
stdatomic.h管理支持并发程序设计的可选库，_Atomic是可选项
类型限定符是幂等的，一条声明中多次使用同一个限定符，多余的限定符将被忽略

const float* pf
pf指向的值不能被改变
float * const pt
pt必须指向同一个地址，但它指向的值可以改变
float const * pfc与const float* pfc相同
void display(const int array[], int limit);
const保证数据不会被更改

volatile限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值
通常被用于硬件地址及在其他程序或同时运行的线程中共享数据
对指针，volatile的语法和const一样
volatile int locl;
locl是一个易变的位置
volatile int* ploc
ploc是一个指向易变的位置的指针

限定符的顺序不重要

restrict只用于指针，表明该指针是访问数据对象的唯一且初始的方式
restrict还可用于形参中的指针

const和restrict在形参中可以像下面一样写
void ofmouth(int al[const], int a2[restrict], int n);	等价于
void ofmouth(int * const al, int * restrict a2, int n);

static情况不同，用作形参里告知编译器如何使用形参
double stick(double ar[static 20]);
表明函数调用中的实参是一个指向数组首元素的指针，且该数组至少有20个元素